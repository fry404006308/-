/*

分析：

f[i][j]表示前i件物品中总重量为j方案的方案是否存在

到

f[i][j]表示前i件物品中总重量为j方案总数


==================================================
==================================================


比如2 1 2 1 1 1的输入数据，就是表示1 1 2 3 3 5 10 20

问题就转化为 1 1 2 3 3 5 10 20 这些砝码，
对里面的每一个取或者不取，可以组成多少个总重量
那么这就是一个非常标准的01背包问题

f[i][j]表示前i件物品中总重量为j方案总数
如 f[4][5]就是表示前4件物品中总重量为5的方案总数
（这里我们设置状态设置的是总重量为j方案总数，
方案总数只要大于等于1，那么就说明重量为j的方案是存在的）

状态转移方程：
当第i件物品不取的时候：
f[i][j]=f[i-1][j]
当第i件物品取的时候：
f[i][j]=f[i-1][j-w[i]]

所以f[i][j]=f[i-1][j] + f[i-1][j-w[i]];
初始状态：
f[k][0]=1
终止状态：
设砝码的总个数为num个
f[num][1000]
当然这个还不是直接所求的，
直接所求就是求1到1000的过程中，哪一些砝码总数的方案不为0即可


算法思路：
1、统计砝码总数，准备好砝码序列
2、初始化动态规划数组，做动态规划
3、统计方案总数

*/


#include <iostream>
using namespace std;
int f[1005][1005]={0};
int main(){
    //1、统计砝码总数，准备好砝码序列
    int num=0;//砝码总数
    int w[1005];//砝码序列
    int a[7]={0,1,2,3,5,10,20};
    for(int i=1;i<=6;i++){
        int x;
        cin>>x;
        for(int j=1;j<=x;j++) w[++num]=a[i];
    }
    //2、初始化动态规划数组，做动态规划
    for(int i=0;i<=1000;i++) f[i][0]=1;
    for(int i=1;i<=num;i++){
        for(int j=1;j<=1000;j++){
            if(j-w[i]>=0)
            f[i][j]=f[i-1][j] + f[i-1][j-w[i]];
            else
            f[i][j]=f[i-1][j];
        }
    }
    //3、统计方案总数
    int count=0;
	for(int i=1;i<=1000;i++){
		if(f[num][i]) count++;
	}
	cout<<"Total="<<count<<endl;
    return 0;
}



