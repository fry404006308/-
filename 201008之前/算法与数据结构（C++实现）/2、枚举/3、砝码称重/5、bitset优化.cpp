
/*

C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，
它的每一个元素只能是０或１，每个元素仅用１bit空间

001000010010001000100100010001


如果选择状态：
f[i][j]表示前i件物品中总重量为j方案的方案是否存在

那么f[i][j]里面存的数据也就是0和1，所以可以用bitset来代替

二维的状态转移方程空间优化之后
f[i][j]=f[i-1][j] || f[i-1][j-w[i]];
就变成一维的
f[j]=[j] || [j-w[i]];

解决j-w[i]>=0之后
f[j+a[i]]=f[j+a[i]] || f[j];
空间优化之后，也可以写成
if(f[j]) f[j+a[i]]=1;


这个时候，f[]这个数组就可以用bitset来代替了


0000000000000000000000000000001

注意：
for(int i=1;i<=6;i++){ //对不同型号的砝码进行循环
    for(int k=1;k<=n[i];k++){ //对同一个型号的多个砝码进行循环
        for(int j=weight;j>=a[i];j--){
            f[j]=f[j] || f[j-a[i]];
        }
    }
}
使用bitset优化砝码称重的多重背包解法的时候，注意点是什么
要解决bitset去掉的那层循环的限制条件，也就是第三层循环中的j>=a[i]，
可以把f[j]=f[j]||f[j-a[i]]中j的位置都加上a[i]即可解决

在砝码称重的bitset的优化中，bitset的左移和右移操作如何确定
由砝码称重这题对应的关系，if(f[j]) f[j+a[i]]=1，由f[j]得到f[j+a[i]]，那么肯定是左移

*/


#include <iostream>
#include <bitset>
using namespace std;
bitset<1005> f;
int main(){
    
    int n[7];
    int a[7]={0,1,2,3,5,10,20};
    for(int i=1;i<=6;i++){
        cin>>n[i];
    }
    //2、初始化动态规划数组，做动态规划
    f[0]=1;
    for(int i=1;i<=6;i++){ //对不同型号的砝码进行循环
        for(int k=1;k<=n[i];k++){ //对同一个型号的多个砝码进行循环
            f=f | f<<a[i];
        }
    }
    //3、统计方案总数

	cout<<"Total="<<(f.count()-1)<<endl;
    return 0;
}









