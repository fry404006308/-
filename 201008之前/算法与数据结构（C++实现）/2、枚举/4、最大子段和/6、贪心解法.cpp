
/*

贪心是每次选择的是局部最优解，
首先开始，只有a[1]，那么这个a[1]就是最优解，也就是连续非空子序列中和最大的
然后我们每增加一个数a[i]，
那么对a[i]而言（也就是说如果我们在子序列中必选a[i]的时候），
如果a[i]之前的序列和大于0，a[i]加上它可以组成子序列的和肯定比只有a[i]更大，
也就是a[i]<a[i]+s[i-1]
如果a[i]之前的序列和小于等于0，那么a[i]完全可以不要之前的序列，
也就是a[i]>=a[i]+s[i-1]

这里表示的a[i]之前的序列，说的是以a[i-1]结尾的连续非空子序列中和最大的序列s[i-1]

我们这里的对a[i]而言，也就是假设了必定选中a[i]的情况
换言之，我们上面贪心的过程求到的最优解就是以a[i]为结尾的子序列和s[i]最大的的局部最优解
而这里，我们在所有的s[i]中找最大的，即max(s[i]|1<=i<=n)，
那么就可以求出a[1]-a[n]所有子序列的全局最优解
所以这个题目是可以用贪心来做的，就是可以由局部最优解得到全局最优解


强调一遍 这题为什么可以用贪心来做：
因为局部最优解表示的是以a[i]为结尾的子序列和最大的s[i]，
而全局最优解直接在所有的s[i]中找最大的就可以了
我们可以由局部最优解，得到全局最优解，自然就可以用贪心来做


一个题目能不能用贪心来做的依据
因为贪心是“鼠目寸光”，求的是局部最优解，
如果局部最优解能够得到全局最优解，那么一个题目就能用贪心来做


算法步骤：
1、找到以a[i-1]结尾的连续非空子序列中和最大s[i-1]
2、
如果这个序列s[i-1]为负数，那么以a[i]结尾的连续非空子序列中和最大的序列就是a[i]本身（本身我们可以看做+0）
如果这个序列s[i-1]为正数，那么以a[i]结尾的连续非空子序列中和最大的序列就是a[i]+s[i-1]
3、在所有的s[i]中找最大的，即max(s[i]|1<=i<=n)


如果用贪心来求这个问题（最大连续子序列的和），输入的数全是负数怎么办，会不会出错
肯定是不会出错的，因为我们贪心的过程是找所有以a[i]结尾的子序列和最大的s[i]，
而得到全局最优解的过程是在s[i]中找最大的，这样囊括了所有的情况，所以肯定是对的

贪心的时间复杂度：
O(n)

贪心优化的原理
贪心能够优化枚举法，是因为贪心着眼于局部的最优策略，
只枚举了极少的局部的情况，所以贪心法有时候不一定对，但是一般效率都还可以


*/
#include <iostream>
#include <algorithm>
using namespace std;
int a[200005];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int sum=a[1];
    int maxx=a[1];
    for(int i=2;i<=n;i++){
        if(sum<=0) sum=0;
        sum+=a[i];
        maxx=max(sum,maxx);
    }
    cout<<maxx<<endl;
    return 0;
}


