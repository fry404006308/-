/*

之前的最大子段和的动态规划的优化的时候，
我们讲了滚动数组优化，
原因是 对应的状态转移方程为：
f[i]=max(f[i-1]+a[i],a[i]) (2<=i<=n)
里面只用到了f[i]和f[i-1]这两个元素，
所以可以用只有两个元素的数组来优化

我们现在的递推表达式是：
f[i]=f[i-1]+f[i-2] (3<=i<=n)
里面用到了f[i]、f[i-1]和f[i-2]三个元素，
所以可以用含有三个元素的数组来优化

滚动数组的代码修改也很简单
直接在递推表达式有i的位置%3即可
f[i%3]=f[(i-1)%3]+f[(i-2)%3];
（%3是因为现在是有三个元素的滚动数组）

注意：
取结果的时候，n也需要模3，例如f[n%3]

*/

#include <iostream>
using namespace std;
const int mod=1000000007;
int f[3];
int main(){
    int n;
    cin>>n;
    //1、确定初始值
    f[1]=f[2]=1;
    //2、循环做递推，3-n
    for(int i=3;i<=n;i++){
        //F(n)=F(n-1)+F(n-2)
        f[i%3]=(f[(i-1)%3]+f[(i-2)%3])%mod;
    }
    //注意n也需要模3
    cout<<f[n%3]<<endl;
    return 0;
}


