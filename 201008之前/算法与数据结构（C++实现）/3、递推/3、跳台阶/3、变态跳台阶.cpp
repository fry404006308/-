/*

题目描述
有N级的台阶，你一开始在底部，
每次可以向上迈最多K级台阶（最少1级），
问到达第N级台阶有多少种不同方式。
输入格式
两个正整数N，K。

输出格式
一个正整数，为不同方式数，由于答案可能很大，
你需要输出ans mod 100003后的结果。

输入输出样例
输入
5 2
输出
8

数据范围：
对于20%的数据,有N<=10, K<=3;
对于40%的数据，有N<=1000;
对于100%的数据，有N<=100000,K<=100。


题目位置：
P1192 台阶问题 - 洛谷
https://www.luogu.com.cn/problem/P1192

*/

/*

分析：
f(n)=f(n-1)+f(n-2)+...+f(n-k)

n=5,k=2
f(5)=f(4)+f(3)

初始状态：
f(1)=1

前k项的值怎么确定
这个时候，问题就变成有k级台阶，
每次可以跳k步，问达到k级台阶有多少种跳法
f(1)=1
f(2)=2
f(3)=f(2)+f(1)+1=4
f(4)=f(3)+f(2)+f(1)+1=8
f(5)=f(4)+f(3)+f(2)+f(1)+1=16

算法思路：
1、确定初始值（前k项）
2、根据递推表达式来做递推

*/
#include <iostream>
using namespace std;
const int mod=100003;
int f[100005]={0};
int main(){
    int n,k;
    cin>>n;cin>>k;
    //1、确定初始值（前k项）
    f[1]=1;
    for(int i=2;i<=k;i++){
        f[i]=1;
        for(int j=1;j<=i-1;j++){
            f[i]=(f[i]+f[j])%mod;
        }
    }
    //2、根据递推表达式来做递推
    //f(n)=f(n-1)+f(n-2)+...+f(n-k)
    for(int i=k+1;i<=n;i++){
        for(int j=1;j<=k;j++){
            f[i]=(f[i]+f[i-j])%mod;
        }
    }
    cout<<f[n]<<endl;
    return 0;
}
