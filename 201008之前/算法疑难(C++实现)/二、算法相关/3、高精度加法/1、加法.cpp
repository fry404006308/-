/*

高精度加法注意：
比如我们计算
797879787978943797398473475345439743874397433434434978798789
+
897238972397398271927987298793532342454374937493343434347493749733434

a、字符串转成数组的时候，我们需要反转，这样方便逐位相加
b、输出的时候也要反转回来


高精度加法原理：
输入的话，就用字符串，这样输入多少位都行
但是计算的时候，我们可以用数组，
数组中的每一位存储一个数字，
相加就逐位相加，然后进位就好


思路：
init
字符串反向转成数组
add
逐位相加，并且进位
print
反向输出数组


字符串反向转成数组
98765

s[4]=a[1]
s[3]=a[2]

56798


*/
#include <iostream>
#include <algorithm>
using namespace std;
int a[1000]={0},b[1000]={0};

//字符串反向转成数组
void init(string s,int a[]){
    //我们把字符串的长度，也就是数字的位数，存在a[0]
    a[0]=s.length();
    //字符串反向转成数组
    for(int i=1;i<=a[0];i++){
        a[i]=s[a[0]-i]-'0';
    }
}

//逐位相加，并且进位
void add(int a[],int b[]){
    //确定a数组和b数组位数的最大值，这样逐位相加做循环的时候好做
    a[0]=max(a[0],b[0]);
    //逐位相加
    for(int i=1;i<=a[0];i++){
        a[i]+=b[i];
    }
    //处理进位
    for(int i=1;i<=a[0];i++){
        if(a[i]/10) a[i+1]+=a[i]/10;
        a[i]%=10;
    }
    //最高位进位的话，要将数字的长度加1
    if(a[a[0]+1]) a[0]++;
}

//反向输出数组
void print(int a[]){
    for(int i=a[0];i>=1;i--){
        cout<<a[i];
    }
    cout<<endl;
}

int main(){
    string sa,sb;
    cin>>sa;
    cin>>sb;
    init(sa,a);
    init(sb,b);
    add(a,b);
    print(a);
    return 0;
}






